// Задание 4. Делегирование и агрегирование
/*
Что нужно сделать:
Представим, что мы создаём имитацию завода. На заводе работают люди, и у каждого своя работа. За работу они получают зарплату. Мы можем направить сотрудника на другую работу, при этом его обязанности и зарплата меняются.
- Для реализации воспользуемся принципами делегирования и агрегирования.
- Реализуйте класс Job, в него должны входить:
приватные поля role (строка) и salary (число);
геттер поля salary;
публичный метод work, который принимает в качестве аргумента строку personName и выводит в консоль: «{personName} сейчас работает как {role}».
- Реализуйте класс Person, в него должны входить:
приватное поле Job;
приватное поле name, которое может быть передано в аргументе конструктора;
сеттер для поля Job;
метод getSalary, который возвращает текущую зарплату сотрудника;
метод work(), который принуждает выполнить текущую работу по профессии.

А теперь настало время приключений:
- Создайте 2-3 экземпляра класса Person, назначьте им имя.
- Создайте несколько объектов типа Job, задав им название профессии и зарплату.
- Задайте вашим сотрудникам первоначальные профессии и заставьте их немного поработать.
- Переквалифицируйте работников на другую профессию и посмотрите, насколько легко изменить поведение объекта с помощью агрегирования.
- Person может работать с любым Job, который он получает снаружи, поэтому можно назвать такое взаимодействие классов агрегированием. Если бы экземпляр класса Job создавался строго внутри класса Person, это бы уже была композиция.
- В классе Job метод work мог иметь в себе любую полезную нагрузку, выполнять задачи на странице или содержать в себе логику. Вам удалось с помощью делегирования и агрегирования создать иерархию классов, в которой изменения производятся легко и быстро практически без дублирования кода. Теперь вы сможете представить, как применить это в реальном проекте. Это и есть делегирование.
*/

// Решение:
/*
1) Структура:
- job.ts:
  - Определяет класс Job, представляющий должность/профессию;
  - Содержит название должности (role) и зарплату (salary);
  - Предоставляет метод work(personName), выводящий сообщение о работе сотрудника на данной должности.
Применение: инкапсулирует информацию о работе, позволяя легко менять детали должности.

- person.ts:
  - Определяет класс Person, представляющий сотрудника;
  - Содержит имя сотрудника (name) и текущую должность (job);
  - Метод setJob(job) позволяет назначать сотруднику должность (агрегирование);
  - Метод getSalary() возвращает зарплату сотрудника, делегируя запрос классу Job;
  - Метод work() заставляет сотрудника работать, делегируя задачу классу Job.
Применение: определяет сотрудника и его взаимодействие с должностью через делегирование и агрегирование.

- main.ts:
  - Создает экземпляры классов Person и Job;
  - Назначает сотрудникам первоначальные должности;
  - Демонстрирует работу сотрудников и получение ими зарплаты;
  - Переназначает сотрудникам должности, показывая гибкость системы (агрегирование).
Применение: исполняемый файл, демонстрирующий взаимодействие классов и принципы делегирования и агрегирования.

2) Ключевые моменты, демонстрирующие принципы делегирования и агрегирования:

- Делегирование:
  - Класс Person делегирует выполнение работы классу Job; 
  - Когда вызывается метод person.work(), он фактически вызывает метод job.work(person.name); 
  - Класс Person делегирует ответственность за выполнение работы классу Job.

- Агрегирование: 
  - Класс Person содержит объект Job, но не владеет им; 
  - Объект Job может существовать независимо от объекта Person; 
  - Person получает Job снаружи через setJob, и Job может быть переназначен другому Person;
  - Если бы Job создавался внутри Person, то это была бы композиция, а не агрегирование.

3) Код демонстрирует, как можно использовать делегирование и агрегирование для создания гибкой и легко изменяемой системы. Изменение работы сотрудника достигается путем простого изменения его связи с другим объектом Job, а не путем изменения самого объекта Person. Это упрощает управление и расширение системы.

4) Примечание:
В коде нет проверки, что объект Job может быть null. Это может привести к ошибке в случае, если работник не имеет должности. Хотя это покрывается в методе getSalary() класса Person, рекомендуется также дополнительно обработать этот случай в самом классе Job - Исправлено.
*/
