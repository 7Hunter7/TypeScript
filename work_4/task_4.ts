// Задание 4. Делегирование и агрегирование
/*
Что нужно сделать:
Представим, что мы создаём имитацию завода. На заводе работают люди, и у каждого своя работа. За работу они получают зарплату. Мы можем направить сотрудника на другую работу, при этом его обязанности и зарплата меняются.
- Для реализации воспользуемся принципами делегирования и агрегирования.
- Реализуйте класс Job, в него должны входить:
приватные поля role (строка) и salary (число);
геттер поля salary;
публичный метод work, который принимает в качестве аргумента строку personName и выводит в консоль: «{personName} сейчас работает как {role}».
- Реализуйте класс Person, в него должны входить:
приватное поле Job;
приватное поле name, которое может быть передано в аргументе конструктора;
сеттер для поля Job;
метод getSalary, который возвращает текущую зарплату сотрудника;
метод work(), который принуждает выполнить текущую работу по профессии.

А теперь настало время приключений:
- Создайте 2-3 экземпляра класса Person, назначьте им имя.
- Создайте несколько объектов типа Job, задав им название профессии и зарплату.
- Задайте вашим сотрудникам первоначальные профессии и заставьте их немного поработать.
- Переквалифицируйте работников на другую профессию и посмотрите, насколько легко изменить поведение объекта с помощью агрегирования.
- Person может работать с любым Job, который он получает снаружи, поэтому можно назвать такое взаимодействие классов агрегированием. Если бы экземпляр класса Job создавался строго внутри класса Person, это бы уже была композиция.
- В классе Job метод work мог иметь в себе любую полезную нагрузку, выполнять задачи на странице или содержать в себе логику. Вам удалось с помощью делегирования и агрегирования создать иерархию классов, в которой изменения производятся легко и быстро практически без дублирования кода. Теперь вы сможете представить, как применить это в реальном проекте. Это и есть делегирование.
*/
