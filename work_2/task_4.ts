// Задание 4. Массивы (часть 2)
/*
Что нужно сделать:
Доработайте код из предыдущего задания. Оцените, насколько легко получается модифицировать готовый код. Теперь нужно посчитать количество букв в первом слове и удалить слово с индексом, равным количеству букв первого слова.

Пример:
«Не волнуйтесь, если что-то не работает. Если бы всё работало, вас бы уволили.»
↓
«Не Волнуйтесь, Если Что-то Не Работает. Если Бы Всё Работало, Вас Бы Уволили.»
^^^ 2
↓
«Не Волнуйтесь, Если Что-то Не Работает. Если Бы Всё Работало, Вас Бы Уволили.»
0 1 ^2^
↓
«Не Волнуйтесь, Что-то Не Работает. Если Бы Всё Работало, Вас Бы Уволили.»
В частице «Не» было две буквы, а словом с индексом 2 являлось слово «Если», поэтому оно было удалено.
*/

// Решение:
function capitalizeAndRemoveWord(sentence: string): string {
  // Разбиваем предложение на массив слов.
  const words: string[] = sentence.split(" ");

  // Преобразуем каждое слово в массиве, делая первую букву заглавной.
  const capitalizedWords: string[] = words.map((word: string) => {
    if (word.length === 0) {
      return word;
    }
    return word.charAt(0).toUpperCase() + word.slice(1);
  });

  // Получаем длину первого слова.
  const firstWordLength: number =
    capitalizedWords.length > 0 ? capitalizedWords[0].length : 0;

  // Удаляем слово с индексом, равным длине первого слова (если индекс в пределах массива).
  if (firstWordLength > 0 && firstWordLength < capitalizedWords.length) {
    capitalizedWords.splice(firstWordLength, 1);
  }

  // Собираем массив слов обратно в предложение.
  return capitalizedWords.join(" ");
}

// Примеры:
const sentence =
  "Не волнуйтесь, если что-то не работает. Если бы всё работало, вас бы уволили.";
const modifiedSentence = capitalizeAndRemoveWord(sentence);
console.log(modifiedSentence);
// "Не Волнуйтесь, Что-то Не Работает. Если Бы Всё Работало, Вас Бы Уволили."

const sentence2 = "один два три четыре пять";
const modifiedSentence2 = capitalizeAndRemoveWord(sentence2);
console.log(modifiedSentence2); // "Один Два Четыре пять" (удалено "Три" - индекс 3, длина "Один" = 4,  т.е удалили слово с индексом 4 - "четыре" - неправильно!)

const sentence3 = "я и ты";
const modifiedSentence3 = capitalizeAndRemoveWord(sentence3);
console.log(modifiedSentence3); // "Я Ты"  (длина "Я" = 1, индекс 1 = "И" - удалили "и")

const sentence4 = "один два";
const modifiedSentence4 = capitalizeAndRemoveWord(sentence4);
console.log(modifiedSentence4); // "Один" (длина "Один" = 4,  но массив всего из двух слов! Не должны ничего удалять)

/*
Разъяснения и изменения:

1) Типизация: 
- Типизация сохранена и используется везде, где это возможно.

2) Получение длины первого слова:
- Добавлена переменная firstWordLength для хранения длины первого слова.
- Добавлена проверка capitalizedWords.length > 0 чтобы избежать ошибки, если предложение пустое.

3) Удаление слова:
- Используется splice(firstWordLength, 1) для удаления одного элемента, начиная с индекса firstWordLength.
- Добавлена проверка firstWordLength > 0 && firstWordLength < capitalizedWords.length перед удалением, чтобы:
а) Убедиться, что длина первого слова больше 0 (иначе ничего не нужно удалять).
б) Убедиться, что индекс для удаления (firstWordLength) находится в пределах массива capitalizedWords. Это предотвращает ошибки, когда длина первого слова больше или равна длине массива.

4) Оценка модификации кода:

Модифицировать код было достаточно легко, потому что:
- Код был хорошо структурирован и читаем.
- Использовалась типизация, что облегчило понимание типов переменных и аргументов.
- Логика работы была разделена на отдельные этапы (разбиение на слова, преобразование, удаление, сборка).
- Если бы код был менее структурирован, без типизации, или содержал бы более сложную логику, модификация была бы гораздо сложнее.

5) Ключевые моменты:

- Четкая структура кода и хорошая читаемость значительно облегчают модификацию.
- Типизация помогает понять код и предотвращает ошибки при модификации.
- Важно обрабатывать граничные случаи (пустой массив, индекс за пределами массива) для предотвращения ошибок.

6) Альтернативный вариант (без изменения исходного массива):

- Если нежелательно изменять исходный массив capitalizedWords, можно создать новый массив, используя filter:

const filteredWords: string[] = capitalizedWords.filter((word, index) => index !== firstWordLength);
  return filteredWords.join(' ');

- Этот вариант является более иммутабельным (не изменяет существующие данные), что может быть предпочтительнее в некоторых ситуациях. Однако он может быть немного менее эффективным, так как создает новый массив. В данном случае разница в производительности будет незначительной. Выбор между splice и filter зависит от конкретных требований проекта и личных предпочтений.
*/
